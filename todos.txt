[v0.4]

1. Fix: 
	[Done]
	1.1. for 'string.capitalize': allow accepting empty strings; 
		Currently, the 'capitalize("")' 'throw's, whereas it should be: 
			'capitalize("") === ""'; 
			
	[Done]
	1.2. BUG: 'string.count()' returns the 'count' value that is lesser than the require amount; 

	[Done]
	1.3. Change the '.constructor === Array' to 'instanceof Array' in 'isArray' function [optimization has proven false...];

	[Done]
	1.4. The export names for submodules; 
		Some of those are _RESERVED__KEYWORDS_!
		That is not acceptable; 
		Ideas: 

			1. typeof -> type 
			2. function -> functional

	[Done]
	1.5. Changed signature for 'tupleSlice', 'tuplePick'; 
		
2. Add: 
	[Done]
	2.1. string.extract(), add third optional argument 'toReplaceWith?: string', which defaults to ""; 
		Then, the function becomes: '(...) => string.split(toExtract).join(toReplaceWith)'; 

	[Done]
	2.2. 'const never = (() => {}) as () => never' - IMMENSELY useful for signifying unreachable return-paths in the application; 
	
	[Done]
	2.4. 'const sum = (...strings: string) => string' - FOR summing up strings; 

	[Done]
	2.5. 'array.empty = () => []' 
	
	[Done]
	2.6. 'object.empty = () => ({})'
	
	[Done]
	2.7. 'object.propertyDescriptors' - get all the property descriptors (recursively, including the '.prototype'-s); 

	[Done]
	2.8. 'array.isPair' - common pattern; 
		
		[Done]
		2.8.1. More generally - 'array.isTuple(n)(x) => isArray(x) && x.length === n'; 

	[Done]
	2.9. 'number. min, max' = 'Math.min()' and 'Math.max'; 

	[Done]
	2.10. A 'array.Pairs<T, K> = Pair<T, K>[]' type; 

		NOTE: do not separate these pieces via exports! 

	[done]
	2.11.  string.lastOut


	[Done]
	2.13. 'type.isTruthy = id'; This is a convinience alias; 

	[Done]
	2.15. 'object.prototype = Object.getPrototypeOf' [convinience method]

	[Done]
	2.16. 'object.findOwnMissing'; 

	[Done]
	2.17. 'object.copy'

	[Done]
	2.18. 'array.tuple'
	
	2.19. JSDoc - look in 'Docs'

	[Done]
	2.20. 'array.insertion'; 

	[Done]
	2.21. 'functional.constant'; 

	[DONE]
	2.22. 'array.out' - a new (last) argument 'count'; 

	[DONE]
	2.23. 'array.lastOut' - a new (last) argument 'count'; 

	[Done; BREAKING!]
	2.24. 'object.structCheck'- added a new optional argument - 'optional' for optional properties; 

	[Done]
	2.25. 'type.isNullary' - checks for 'x == null'

	[Done]
	2.26. 'array.same'
	
	[Done]
	2.27. 'array.uniqueArr'

	[Done]
	2.28. 'string.concat'

	[DOne]
	2.29. 'array.setLast'

	[Done]
	2.30. 'array.or'

	[DONe]
	2.31. 'array.and'

	[Done]
	2.32. 'type.isFalsy'

	[Done]
	2.33. 'object.allocator'

	[Done]
	2.34. 'array.allocator'

	[Done]
	2.35. 'object.same'

	[Done]
	2.36. 'string.isEmpty'

	[Done]
	2.37. 'number.isEven'

	[Done]
	2.38. 'number.isOdd'

	[Done]
	2.39. 'number.makeEven'

	[Done]
	2.40. 'number.makeOdd'

	[Done]
	2.41. 'array.lastIndex'

	[Done]
	2.42. 'string.lastIndex'

3. Delete: 
	3.1 [done]. The 'declarationMap: true' option - ONLY WASTES SPACE; 
		It doesn't do ANYTHING useful when there are no '.ts' files provided; 

	[Done]
	3.2. middleOutN
	
	[Done]
	3.3. middleOutP

	[Done]
	3.4. 'set' module

	[Done]
	3.5. 'tree' module
		Reason: no application [more exactly - too narrow application]
	
	[Done]
	3.6. 'curry' function

4. Docs: 
	use the 'GitHub Wiki', namely - the 'Github Wiki' REFERENCES the JSDoc; 
	Reason for that - easier [faster] to see online once, then use ALL THE TIME inside the editor, than the reverse;
	And 'one.js' is so small, it actually makes sense (the user will be remembering names + purposes of functions and needing to look them up A LOT, 
		NOT remembering a lib/framework and knowing what this is automatically); 

5. Tests

	2. Modules to make new tests for: 

		7. object
			1. kv
			2. dekv
			3. structCheck
			4. keys
			5. values
			6. recursiveStringKeys
			7. recursiveSymbolKeys
			8. ownProperties
			9. ownKeys
			10. ownValues
			11. prototype
			12. copy
			13. propertyDescriptors
			14. findOwnMissing
			15. empty
			16. allocator
			17. same
		9. type
			1. isNumber
			2. isFunction
			3. isString
			4. isBoolean
			5. isSymbol
			6. isObject
			7. isNull
			8. isUndefined
			9. isNullary
			10. typeOf
			11. isArray
			12. isSet
			13. isNumberConvertible
			14. isTruthy
			15. isFalsy

6. Logs [write the changelogs]; 

7. Publishing: 

	1. Delete the 'source-map's [needed for debugging only]
	2. Remove the 'dist' manually
	3. Do 'npm run all'
	4. Try doing 'npm pack' (until the moment that the list of exported stuff is precisely as it's supposed to be)
	5. Do 'npm run publish'

8. Future: 

	0. prior to all this, however...
		Add: 
			1. string: 
				1. camelCase - works on a spread list of words, combines them using camelCase
				2. PascalCase - works like camelCase
				3. kebab_case - [kebab-case] works like camelCase
				4. snake_case - works like camelCase
				5. MACRO_CASE - works like camelCase
				6. flatcase - works like camelCase
				7. UPPERCASE - works like camelCase
				8. TRAIN_CASE - [TRAIN-CASE] works like camelCase
				9. Title_Case  - works like camelCase
				10. Http_Case - [Http-Case] works like camelCase
				11. camel_Snake_Case - works like camelCase

		Fix: 	

			1. string: 
				1. extract - add a 'global' call from the 'parsers.js' 'regex' submodule;
					Reason - it's impossible to use '.split' with non-global 'regex'; 

					For this to be good - SEPARATE the 'regex' submodule of 'parsers.js' into 'make-regex' npm package, 
						which would (basically) be a whole new module. 

					Then - one.js can import it [and subsequently EXPORT it, as part of the "combination-package" thing], TOGETHER
						with 'parsers.js' [due to: 1. how conviniently it fits with parsers.js functionality; 2. that it already IS a dependency - why not export it as well?]

	1. functional programming library in JavaScript: 
		Let the 'functional' module be moved there...
		The purpose of one.js is: 

			1. to provide refactoring for some simple/elementary expressions (like 'array.out')
			2. to serve as a "clarifier" for existing JS API that is far too complex (the '.splice' method for instance...)
			3. to provide solutions to simple algortihms (like 'set.uniqueArr')
		
		Even though the 'trivialCompose' IS extremely common-place, it is still (technically) a functional utility; 

	2. create a new library called 'shape.js', which would elaborate on the idea of 'structCheck'. 
		Particularly: 

			1. It would introduce a new class called Shape, which would be the basis for 'structCheck' [rename to 'Shape.is']
				The shapes would also be [method enumeration]: 

					1. comparable [checkable for equality]
					2. intersectable [intersections of different shapes would be findable]
					3. disjoinable [possible if it's impossible for a given object to have 2 types at the same time]

					4. constructable: 	
						There would be the '.or' and '.and' predicate-methods for constructing new shapes from current ones. 
					
					5. constructor-like: 
						It would be possible to construct new object of given shape using specialized 'Shape.prototype.construct' method

			2. There would be the 'is' function, that would take a list of 'Shape's, then return a set of 'Shape's that 
				the given object possesses.
	
	3. create a new library 'object.js', based off the 'one.js/object' submodule
		The 'object.js' library would (then) become the 'one.js/object' submodule [library-level refactoring]

	4. refactor all the stuff from 'type' submodule into a specialized 'typeof.js' module. 
		This 'typeof.js' module would then become a dependency of 'one.js' that is exported;

	5. refactor all the stuff from 'array' and 'inplace' submodules into 'array.js' module. 
		Then - split the dependency of 'one.js' that is the 'array.js' into 'inplace' and 'array'

	6. add a new package 'bits' for "common" functions for working with binary data, binary interfaces
		Later (when it grows large enough), refactor into another library 'bits.js'
	
	NOTE: after all this - the 'one.js' [more or less] finishes its development, one never touches its "structCheck" part again. 
		And - the package [more or less] does not update anymore, only occasionally - to work on the remaining "small" modules:

			1. boolean
			2. map
			3. number
			4. string

		7. IDEA: [possibly] try to put these small functions into respective submodules, 
			so that nothing would be "lost". 

			BUT - here, retain the ordering [in that - the code would come from FEWER libraries, but the number of submodules would remain the same]. 
			Libraries-modules distribution would be: 

				1. boolean -> functional 
				2. number -> functional 
				3. map -> object/map [note: this is a submodule of the 'object.js' separate module]
				4. string -> functional/string [note: this is a submodule of the functional library]

	8. 'scale.js' - a scalable utility library. 
		It would contain various functions, such as 'array.map', 'array.filter' [which execute BETTER than '.map' and '.filter' WHEN the inputs are large enough/have certain properties].
			The library would provide 'fastMap', 'fastFilter', ..., to work with large pieces of data [for which it is more optimal to choose these manual solutions than the builtin Array.prototype methods]; 
			THIS WAY, let the 'array.js' [and other such libraries] be USED by the 'scale.js'; 

			TODO: create more similar functions for non-Array datatypes

	9. About 'npm run paranoid' - [note for self: generally, when trying out the WSL - introduce into this scheme 2 more items: 
		1. pre-testing [via pre-npm-run-test + a specialized run-all script]
		2. publishing ONLY if the tests pass successfully [possibly - write a specialized npm module/gist for that? So that the user may import the respective function into their own script and be done with it???]
	]

		Particularly, the 'npm run paranoid' should look something like in Bash: 

			rm -rf dist && && npm run all && (npm pack > packing.txt)

		With an updated 'npm run all' being: 	

			npm run build && npm run test-compile && npm run test