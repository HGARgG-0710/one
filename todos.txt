[v0.5]

1. Finish adding the GitHub Workflows: 
	Reusable: 
		1. make-tag.yml - creates a tag for the project
			[NOTE: do this one SEPARATELY; Reason - one MAY need a passphrase, and (hence), one MAY need to learn to pass it as well... SEPARATELY...]; 
			0. auth into 'git' using your credentials; 
				Those are stored as repository SECRETS: 

					0. Your user-name
					1. Your email
					2. Your SSH key; 
					3. [Maybe] Your passphrase; 

			1. '@actions/checkout'
		
			2. '@actions/setup-node'

			3. run-tests.yml [sub-task]
			
			[NOTE: SEPARATELY - run first WITHOUT committing; JUST add a 'git status' to check that the local repo is COMMIT-VIABLE]
			4. run 'npm version [CURRENT_VERSION]'
				1.1. Here, 'CURRENT_VERSION' is a GitHub-repository-level secret, 
					purpose of which is to contain valid semver for the current package version. 
					[This case - '0.5.0']

			[NOTE: when doing this FINAL step - squash the changes into A SINGLE commit...]; 
			5. git add .
			6. git commit -m "updating npm package version"
			7. git tag [secrets.CURRENT_VERSION] -F CHANGELOG.md
				Note: one will need to WRITE the 'CHANGELOG.md' BEFORE doing this...; 
					Commit it on 'main'
			8. git remote set-url origin git@github.com:username/repo-name.git
			9. git push origin main --set-upstream --tags

		[separate commit - just in case...]; 
		2.1. Preparations: 
			1. create a new npm token: 
				1. COPY-TO-CLIPBOARD AND SAVE IT IMMIDIATELY to the flash drive (or somewhere...)
			2. install (locally) the 'act' tool [https://github.com/nektos/act]
				1. NOTE: one *MAY* need to finally move to WSL specifically for this (as doing this on pure Windows seems to be plain unreasonable...)
					Reason - the runner one uses is 'linux' (one most certainly wouldn't use any other), therefore - one needs a local Linux environment to mimic its behaviour...; 
				2. Then - save the SSH key from GitHub there (and other things...), connect to GitHub appropriately, and - COPY ALL THE REPOS! 
			3. create a 'mock' temporary '.github/workflows/npm-pack.yml' file, which would be EXACTLY the same as the 'npm-deploy' except for a few things - it'd:
				1. replace the 'npm publish' with 'npm pack'; 
				2. configure the 'setup/node' action appropriately, to create a default .npmrc file [/w registry URL and Auth Token]: 
					2.1. setup the NODE_AUTH_TOKEN environment variable
						2.1.1. provide it with the value obtained from the 'NPM_TOKEN' secret configured on GitHub as the newly created npm token
					2.2. add the appropriate 'registry: ...' field to the 'setup-node' args [to automatically create an '.npmrc' file]; 
				3. printf [secrets]: NPM_TOKEN, GITHUB_TOKEN, 
			4. Create appropriate GitHub Secrets ("npm publish"-related): 

			5. run the "mock versions" of 'make-release-patch.yml' and 'make-release-minor.yml' locally [see how they work]; 
				THESE are exactly the same as your current ones BUT: 
					1. they do *not* log into GitHub + git push to the repo
					2. INSTEAD, there is A WHOLE SEPARATE '.yml' file SPECIFICALLY for connecting to GitHub via SSH (via the user profile provided with the chosen Secrets); 
						Its' contents are used to ensure that, indeed, the whole thing is working as intended...; 
						After - they are copied into the final 'make-release-patch.yml' and 'make-release-minor.yml'
			
			6. For .yml files 1. and 2., write the APPROPRIATE GitHub auth: 
				specifically, add the SSH key [as a secret] needed to connect to GitHub;

		3. npm-deploy - [on push to 'main' - DO IT LAST]: 
			-1. CONFIGURED AS [explanation - fires ONLY upon CREATION of a RELEASE (*not* a tag - that's what 'make-tag' is for...)]: 
				on: 
					release: 
						types: [published]

			0. runs the 'run-tests' workflow as a reusable workflow
			1. 'npm publish --provenance --access public'

2. Add the workflow files in question to the 'GitHub Gist' 
	[specifically - the 2 first, the 'mock' one and the 'npm-deploy' one, it'd be using the convention of 'run-tests.yml' to designate the testing procedure...];

2. Changelog [early]: 
	1. Add: 
		1. array: 
			1. substitute
			2. sort
		2. functional: 
			1. argFiller
			2. copy
			3. argWaster
			4. has
		3. object: 
			1. prop
			2. classes [module]: 
				1. classWrapper
				2. withoutConstructor
				3. mixin
				4. delegateMethod
				5. delegateProperty
				6. calledDelegate
			3. propDefine
			4. Prototypal
			5. protoProp	
			6. descriptor [module]: 
				1. GetSetDescriptor
				2. ConstDescriptor
				3. Descriptor
				4. EnumerableDescriptor
				5. ConfigurableDescriptor
				6. WritableDescriptor	
			8. extendPrototype
		4. string: 
			1. charCodeAt
		
	2. Remove [breaking]: 
		1. object: 
			1. FullKey

3. add docs [JSDoc + update the 'wiki...']; 

4. add tests

8. Future: 

	0. prior to all this, however...
		Add: 
			1. string: 
				1. camelCase - works on a spread list of words, combines them using camelCase
				2. PascalCase - works like camelCase
				3. kebab_case - [kebab-case] works like camelCase
				4. snake_case - works like camelCase
				5. MACRO_CASE - works like camelCase
				6. flatcase - works like camelCase
				7. UPPERCASE - works like camelCase
				8. TRAIN_CASE - [TRAIN-CASE] works like camelCase
				9. Title_Case  - works like camelCase
				10. Http_Case - [Http-Case] works like camelCase
				11. camel_Snake_Case - works like camelCase

		Fix: 	

			1. string: 
				1. extract - add a 'global' call from the 'parsers.js' 'regex' submodule;
					Reason - it's impossible to use '.split' with non-global 'regex'; 

					For this to be good - SEPARATE the 'regex' submodule of 'parsers.js' into 'make-regex' npm package, 
						which would (basically) be a whole new module. 

					Then - one.js can import it [and subsequently EXPORT it, as part of the "combination-package" thing], TOGETHER
						with 'parsers.js' [due to: 1. how conviniently it fits with parsers.js functionality; 2. that it already IS a dependency - why not export it as well?]

			2. for types: 
				1. Use 'NoInfer' where beneficial [example: 'functional.constant']; 

	1. functional programming library in JavaScript: 
		Let the 'functional' module be moved there...
		The purpose of one.js is: 

			1. to provide refactoring for some simple/elementary expressions (like 'array.out')
			2. to serve as a "clarifier" for existing JS API that is far too complex (the '.splice' method for instance...)
			3. to provide solutions to simple algortihms (like 'set.uniqueArr')
		
		Even though the 'trivialCompose' IS extremely common-place, it is still (technically) a functional utility; 

	2. create a new library called 'shape.js', which would elaborate on the idea of 'structCheck'. 
		Particularly: 

			1. It would introduce a new class called Shape, which would be the basis for 'structCheck' [rename to 'Shape.is']
				The shapes would also be [method enumeration]: 

					1. comparable [checkable for equality]
					2. intersectable [intersections of different shapes would be findable]
					3. disjoinable [possible if it's impossible for a given object to have 2 types at the same time]

					4. constructable: 	
						There would be the '.or' and '.and' predicate-methods for constructing new shapes from current ones. 
					
					5. constructor-like: 
						It would be possible to construct new object of given shape using specialized 'Shape.prototype.construct' method

			2. There would be the 'is' function, that would take a list of 'Shape's, then return a set of 'Shape's that 
				the given object possesses.
	
	3. create a new library 'object.js', based off the 'one.js/object' submodule
		The 'object.js' library would (then) become the 'one.js/object' submodule [library-level refactoring]

	4. refactor all the stuff from 'type' submodule into a specialized 'typeof.js' module. 
		This 'typeof.js' module would then become a dependency of 'one.js' that is exported;

	5. refactor all the stuff from 'array' and 'inplace' submodules into 'array.js' module. 
		Then - split the dependency of 'one.js' that is the 'array.js' into 'inplace' and 'array'

	6. add a new package 'bits' for "common" functions for working with binary data, binary interfaces
		Later (when it grows large enough), refactor into another library 'bits.js'
	
	NOTE: after all this - the 'one.js' [more or less] finishes its development, one never touches its "structCheck" part again. 
		And - the package [more or less] does not update anymore, only occasionally - to work on the remaining "small" modules:

			1. boolean
			2. map
			3. number
			4. string

		7. IDEA: [possibly] try to put these small functions into respective submodules, 
			so that nothing would be "lost". 

			BUT - here, retain the ordering [in that - the code would come from FEWER libraries, but the number of submodules would remain the same]. 
			Libraries-modules distribution would be: 

				1. boolean -> functional 
				2. number -> functional 
				3. map -> object/map [note: this is a submodule of the 'object.js' separate module]
				4. string -> functional/string [note: this is a submodule of the functional library]

	8. 'scale.js' - a scalable utility library. 
		It would contain various functions, such as 'array.map', 'array.filter' [which execute BETTER than '.map' and '.filter' WHEN the inputs are large enough/have certain properties].
			The library would provide 'fastMap', 'fastFilter', ..., to work with large pieces of data [for which it is more optimal to choose these manual solutions than the builtin Array.prototype methods]; 
			THIS WAY, let the 'array.js' [and other such libraries] be USED by the 'scale.js'; 

			TODO: create more similar functions for non-Array datatypes

	9. About 'npm run paranoid' - [note for self: generally, when trying out the WSL - introduce into this scheme 2 more items: 
		1. pre-testing [via pre-npm-run-test + a specialized run-all script]
		2. publishing ONLY if the tests pass successfully [possibly - write a specialized npm module/gist for that? So that the user may import the respective function into their own script and be done with it???]
	]

		Particularly, the 'npm run paranoid' should look something like in Bash: 

			rm -rf dist && && npm run all && (npm pack > packing.txt)

		With an updated 'npm run all' being: 	

			npm run build && npm run test-compile && npm run test
	
	10. make the .yml files in the '.github/workflows' a GitHub Gist [expecting those to be rather frequently used...]; 